---
title: 3.无重复字符的最长子串
date: 2019-10-08 18:58:49
tags:
LeetCode
---
# 题目
```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

# 初始思路
可以准备一个桶，用于记录已经出现的字符，可以解决判断重复字符的问题 ，还需要解决记录已形成的子串的长度问题，可以准备一个额外的字符串变量，记录已知的最长的子串。
在形成新的子串时，遇到重复的 字符便终止形成 然后比较是否是新的最长子串。
然后记录已出现的字符时，可以记录字符出现的位置，这样形成子串时遇到重复的字符只需要回到重复字符上次出现的位置即可

# 1A代码
```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录已经找到的子串中最长的长度
        int maxLength = 0;
        // 字符串的长度
        int strLength = s.length();
        //
        HashMap<Character, Integer> charMapToPos = new HashMap<>();
        // 当前寻找的子串的起始位置
        int startPos = 0;
        while (startPos < strLength) {
            StringBuilder temp = new StringBuilder();
            for (int j = startPos; j < strLength; ++j) {
                // 发现重复
                if (charMapToPos.containsKey(s.charAt(j))) {
                    if (temp.length() > maxLength) {
                        maxLength = temp.length();
                    }

                    startPos = charMapToPos.get(s.charAt(j)) + 1;
                    charMapToPos.clear();
                    break;
                }
                else {
                    temp.append(s.charAt(j));
                    charMapToPos.put(s.charAt(j), j);
                }
            }

            if (temp.length() > maxLength) {
                maxLength = temp.length();
                break;
            }
        }

        return maxLength;
    }
}
```

# 继续思考
之前的代码一直有一个temp字符串记录已有的字符串，但其实可以直接记录下标，记录子串的开始下标以及结束下标即可

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int maxLength = 0;

        int leftPos = 0;

        int rightPos = 0;

        int length = s.length();

        HashMap<Character, Integer> charMapToPos = new HashMap<>();

        while (length - leftPos > maxLength && rightPos < length) {
            char c = s.charAt(rightPos);
            if (charMapToPos.containsKey(c) && charMapToPos.get(c) >= leftPos) {
                maxLength = Math.max(rightPos - leftPos, maxLength);
                leftPos = charMapToPos.get(c) + 1;
            }

            charMapToPos.put(c, rightPos);
            ++rightPos;
        }

        maxLength = Math.max(rightPos - leftPos, maxLength);

        return maxLength;
    }
}

```


