---
title: 4.寻找两个有序数组的中位数
date: 2019-10-10 15:34:08
tags:
- LeetCode
---
# 题目
```
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

# 初始思路
计算出两个数组合并后的长度，得到中位数所在的游标，然后通过双游标遍历两个数组的方式合并数组，找到合并后的数组的中位数所在的位置即可。
```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int lengthOf1 = nums1.length;
        int lengthOf2 = nums2.length;

        boolean odd = (lengthOf1 + lengthOf2) % 2 == 0;
        int mediumPos = (lengthOf1 + lengthOf2 + 1) / 2;

        int posOf1 = 0, posOf2 = 0, currentPos = 0;

        int preNum = 0, currentNum = 0;
        double result = 0;

        while (posOf1 < lengthOf1 || posOf2 < lengthOf2) {
            preNum = currentNum;

            if (posOf1 < lengthOf1 && posOf2 < lengthOf2) {
                if (nums1[posOf1] < nums2[posOf2]) {
                    currentNum = nums1[posOf1];
                    posOf1++;
                }
                else {
                    currentNum = nums2[posOf2];
                    posOf2++;
                }
            }
            else {
                if (posOf1 < lengthOf1) {
                    currentNum = nums1[posOf1];
                    posOf1++;
                }
                else {
                    currentNum = nums2[posOf2];
                    posOf2++;
                }
            }

            currentPos++;

            // 如果是偶数
            if (odd) {
                if (currentPos == mediumPos + 1) {
                    // 到了中间位置
                    result = (preNum + currentNum) / 2D;
                }
            }
            else {
                if (currentPos == mediumPos) {
                    result = (double) currentNum;
                }
            }
        }

        return result;
    }
}
```

# 优化
对于其中的合并部分 其实可以有更好的办法，优化后的代码如下
```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int lengthOf1 = nums1.length;
        int lengthOf2 = nums2.length;

        boolean odd = (lengthOf1 + lengthOf2) % 2 == 0;
        int mediumPos = (lengthOf1 + lengthOf2 + 1) / 2;

        int posOf1 = 0, posOf2 = 0, currentPos = 0;

        int preNum = 0, currentNum = 0;
        double result = 0;

        while (posOf1 < lengthOf1 || posOf2 < lengthOf2) {
            preNum = currentNum;

            if (posOf1 < lengthOf1 && (posOf2 >= lengthOf2 || nums1[posOf1] < nums2[posOf2])) {
                currentNum = nums1[posOf1];
                posOf1++;
            }
            else {
                currentNum = nums2[posOf2];
                posOf2++;
            }

            currentPos++;

            // 如果是偶数
            if (odd) {
                if (currentPos == mediumPos + 1) {
                    // 到了中间位置
                    result = (preNum + currentNum) / 2D;
                }
            }
            else {
                if (currentPos == mediumPos) {
                    result = (double) currentNum;
                }
            }
        }

        return result;
    }
}
```
