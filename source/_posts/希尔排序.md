---
title: 希尔排序
date: 2019-08-08 16:18:27
tags: 排序
---
# 思想

希尔排序是插入排序的改进版本，主要是考虑到了插入排序的一个优势和一个劣势。

- 优势：插入排序针对整体比较有序的数据排序时 效率非常高 几乎可以达到$O(n)$(最有情况下就是O(n))

- 劣势：插入排序进行插入操作时，需要一一移动位置，并且很有可能发生多次，比如一组数据中的最后一个数是整个数据中的最小值，就会导致每个元素都要发生移动。

希尔排序就是利用了插入排序的优势，并改进了算法避免了劣势，所谓的改进是每次比较N个两两相隔一定距离d的元素进行排序，这样就避免了一个一个移动元素的事件的发生。通过距离d将数组分为多组数据，分别对每组数据进行插入排序，这样就可以使数据的交换比较有跳跃性。完成一次分组排序后便缩小d的大小，直到d缩小为1，d缩小为1时就只剩1组数据量，基本上这组数组已经是有序的了，再进行插入排序基本上只有一些微小的调整了，直接进行插入排序是非常高效的

# 时间复杂度
希尔排序的时间复杂度依赖于选择的 间隔序列， 但一般比$O(n^2)$要好，经过数学上的推算，希尔排序平均的复杂度可以达到$O(n^1.3)$


# 代码
```
#include <iostream>

void shellSort(int nums[], int length);
void swap(int nums[], int i, int j);
void printArray(int *nums, int length);


int main()
{
    int nums[] = {10, 21, 22, 35, 39, 18, 30, 89};
    int length = sizeof(nums) / sizeof(nums[0]);
    shellSort(nums,length);
    printArray(nums, length);
}

void shellSort(int nums[], int length){
    int gap = length / 2; //这里用总长度的一半作为初始gap
    while(gap >= 1){
        //写代码的时候可以从gap为1的情况下考虑
        //相比较插入排序而言，最大的不同就是希尔排序的数据间隔是gap 而不是传统的1
        for(int i = gap; i < length; ++i){
            int currentValue = nums[i];
            int j = i - gap;
            //寻找插入位置
            while(j > 0 && currentValue < nums[j]){
                //把大于要插入的值的 数 向后移动一位(一个 gap)
                nums[j + gap] = nums[j];
                j -= gap;
            }
            nums[j + gap] = currentValue;
        }
        gap /= 2;
    }
}

void swap(int nums[], int i, int j)
{
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

void printArray(int *nums, int length)
{
    for (int i = 0; i < length; ++i)
    {
        printf("%d ", nums[i]);
    }
    printf("\n");
}

```
