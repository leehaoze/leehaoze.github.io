---
title: 插入排序
date: 2019-08-08 14:46:27
tags: 排序
---
# 思想

插入排序非常类似于打牌时摸牌的过程，给你一个数组，单独拿出第一张 认为是有序的，然后拿出第二张根据大小插入到第一张之前或之后，再拿出第三张插入到第一张或第二张之前或之后的合适位置，不断重复即可完成排序。

# 时间复杂度

- 最好情况下数组已经是有序的了，那么在遍历中 每个数据只需要与他前面的数比较一次就结束了 总共需要遍历`(n-1)`次，时间复杂度是$O(n)$

- 最坏情况下数组是完全逆序的，那么在遍历中，第i个数据都需要比较`i`次，一共是要遍历`n-1`个数据，总共需要比较$1 + 2 +\dots+(n-1)=\frac{n(n-1)} {2}$，时间复杂度是$O(n^2)$

- 平均情况下 第i个数据最好需要比较`1`次，最坏需要比较`i-1`次，平均比较`i/2`次，一共要遍历`n-1`个数据，总共需要比较$\frac{1}{2} + 1 + \frac{3}{2} + 2 + \frac{5}{2} + \dots+\frac{n-1}{2} = \frac{n(n-1)}{4}$，时间复杂度也是$O(n^2)$

# Code
#include <iostream>

void insertSort(int nums[], int length);
void swap(int nums[], int i, int j);
void printArray(int *nums, int length);

int main()
{
    int nums[] = {10, 21, 22, 35, 39, 18, 30, 89};
    int length = sizeof(nums) / sizeof(nums[0]);
    insertSort(nums, length);
    printArray(nums, length);
}

void insertSort(int nums[], int length)
{
    //默认第0个数据是有序的 直接从无序的部分开始
    for (int i = 1; i < length; ++i)
    {
        int currentValue = nums[i];
        int index = i - 1;
        //挑选合适的位置 index>0保证当前值为最小值时不会越界
        while (index > 0 && currentValue < nums[index])
        {
            //当前值小于上一个位置的值，将上个位置的值向后挪空出位置
            nums[index + 1] = nums[index];
            index--;
        }
        //while循环结束意味着找到了合适的位置
        nums[index + 1] = currentValue;
    }
}

void swap(int nums[], int i, int j)
{
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

void printArray(int *nums, int length)
{
    for (int i = 0; i < length; ++i)
    {
        printf("%d ", nums[i]);
    }
    printf("\n");
}
